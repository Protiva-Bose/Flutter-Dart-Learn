ğŸ¯ ğŸ› ï¸ Actions (Properties) of Image(Assett/Network):
In Flutter, the Image widget is used to display images from various sources like assets (local) or network (online). 
It comes with multiple properties to customize the display, size, and behavior of images.

âœ¨ Common Properties of Image Widget:
Property	                           Description	                                                        Example
image	                               Defines the image source (Asset/Network)	                            AssetImage('assets/image.png')
width	                               Sets the width of the image	                                        width: 200
height	                             Sets the height of the image	                                        height: 150
fit	                                 Controls how the image fits inside its container	                    BoxFit.cover
alignment	                           Aligns the image within its box	                                    Alignment.center
repeat	                             Defines how the image repeats (if smaller than its container)	      ImageRepeat.repeat
color	                               Applies a color filter to the image	                                Colors.blue.withOpacity(0.5)
colorBlendMode	                     Defines how the color filter is applied	                            BlendMode.colorBurn
loadingBuilder	                     Displays a loading indicator while the image loads	                  CircularProgressIndicator()
errorBuilder	                       Shows an alternative widget when the image fails to load	            Icon(Icons.error)


âœ¨ Loading Image from Different Sources
1ï¸âƒ£ Load Image from Assets (Local)
Image.asset(
  'assets/images/sample.png',
  width: 200,
  height: 200,
  fit: BoxFit.cover,
)


âœ” Requires adding the image path in pubspec.yaml
flutter:
  assets:
    - assets/images/sample.png


2ï¸âƒ£ Load Image from Network
Image.network(
  'https://example.com/sample.jpg',
  width: 300,
  height: 200,
  fit: BoxFit.cover,
)

âœ” Requires Internet Permission in Android (AndroidManifest.xml):
<uses-permission android:name="android.permission.INTERNET"/>



âœ¨ Handling Image Loading & Errors
1ï¸âƒ£ Show a Loading Indicator while Image Loads
Image.network(
  'https://example.com/sample.jpg',
  loadingBuilder: (context, child, loadingProgress) {
    if (loadingProgress == null) return child;
    return Center(child: CircularProgressIndicator());
  },
)

2ï¸âƒ£ Show an Error Widget if the Image Fails to Load
Image.network(
  'https://example.com/invalid.jpg',
  errorBuilder: (context, error, stackTrace) {
    return Icon(Icons.error, size: 50, color: Colors.red);
  },
)



âœ¨ Applying Effects & Transformations

1ï¸âƒ£ Add Rounded Borders to an Image
ClipRRect(
  borderRadius: BorderRadius.circular(20),
  child: Image.asset('assets/sample.png'),
)


2ï¸âƒ£ Apply a Color Filter to an Image
ColorFiltered(
  colorFilter: ColorFilter.mode(Colors.red, BlendMode.colorBurn),
  child: Image.asset('assets/sample.png'),
)


3ï¸âƒ£ Make Image Clickable (Tap Action)
GestureDetector(
  onTap: () {
    print("Image Clicked!");
  },
  child: Image.asset('assets/sample.png'),
)


4ï¸âƒ£ Display an Image with Text Overlay
Stack(
  children: [
    Image.asset('assets/sample.png'),
    Positioned(
      bottom: 10,
      left: 10,
      child: Text("Flutter Image", style: TextStyle(color: Colors.white)),
    ),
  ],
)


âœ¨ Summary
Feature	                               Property/Method	                                Example
Display Local Image	                   Image.asset()	                                  Image.asset('assets/sample.png')
Display Online Image	                 Image.network()	                                Image.network('https://example.com')
Resize & Fit	                         fit: BoxFit.cover	                              fit: BoxFit.contain
Handle Errors	                         errorBuilder	                                    errorBuilder: (context, error, stackTrace) => Icon(Icons.error)
Loading Indicator	                     loadingBuilder	                                  loadingBuilder: (context, child, progress) => CircularProgressIndicator()
Apply Opacity	                         Opacity	                                        Opacity(opacity: 0.5, child: Image.asset())
Clickable Image	                       GestureDetector	                                onTap: () { print("Clicked"); }



ğŸ¯ ğŸ› ï¸ Actions (Properties) of Icon:
The Icon widget in Flutter is used to display material design icons. It provides various properties to control its appearance and behavior.

âœ¨ Common Properties of Icon:
Property	                                Description	                                Example Usage
icon	                                    Defines the icon to display.	              Icons.home, Icons.star
size	                                    Sets the size of the icon.	                size: 50
color	                                    Changes the color of the icon.	            color: Colors.blue
semanticLabel	                            Provides a description for accessibility.	  "Home Icon"

âœ¨  Wrapping Icon with IconButton
To make the icon interactive, use IconButton:
IconButton(
  icon: Icon(Icons.add),
  onPressed: () {
    print("Button Pressed!");
  },
)


âœ¨ Applying Shadows & Effects
To apply effects, wrap Icon in a Container:
Container(
  decoration: BoxDecoration(
    shape: BoxShape.circle,
    boxShadow: [
      BoxShadow(color: Colors.black26, blurRadius: 5, spreadRadius: 2),
    ],
  ),
  child: Icon(Icons.favorite, size: 50, color: Colors.red),
)


âœ¨ Customizing Icons with Transform
Rotate or scale the icon:
Transform.rotate(
  angle: 0.5, // Rotate in radians
  child: Icon(Icons.refresh, size: 50),
)


âœ¨ Animating Icons
Use AnimatedSwitcher for smooth transitions:
AnimatedSwitcher(
  duration: Duration(seconds: 1),
  child: Icon(Icons.favorite, key: ValueKey(Icons.favorite), size: 50, color: Colors.red),
)


âœ¨ Summary
Feature	                   Property/Method	                          Example
Set Icon	                 Icons.home	                                Icon(Icons.home)
Change                     Size	size	                                size: 50
Change                     Color	color	                              color: Colors.blue
Make Clickable	           IconButton	                                onPressed: () {}
Apply Shadow	             BoxShadow	                                BoxDecoration(boxShadow: [...])



ğŸ¯ ğŸ› ï¸ Actions (Properties) of Container:
The Container widget in Flutter is a versatile box that can hold other widgets. It provides layout, styling, positioning, and interaction options.

âœ¨ Common Properties of Container
Property	                Description	                                   Example Usage
width	                    Sets the width of the container.	             width: 200
height                    Sets the height of the container.	             height: 100
color	                    Background color of the container.	           color: Colors.blue
alignment	                Aligns child inside the container.	           alignment: Alignment.center
margin	                  Adds space outside the container.	             margin: EdgeInsets.all(10)
padding	                  Adds space inside the container.	             padding: EdgeInsets.all(15)
decoration	              Adds border, shadow, gradient, etc.	           BoxDecoration(...)
constraints	              Defines min/max size of the container.	       BoxConstraints(minWidth: 100, maxWidth: 300)
child	                    Holds a single widget inside the container.	   child: Text("Hello")


âœ¨ Applying Border, Radius & Shadow:
Container(
  width: 200,
  height: 100,
  decoration: BoxDecoration(
    color: Colors.blue,
    borderRadius: BorderRadius.circular(20),
    boxShadow: [
      BoxShadow(color: Colors.black26, blurRadius: 5, spreadRadius: 2),
    ],
  ),
)

âœ¨ Gradient Background:
Container(
  decoration: BoxDecoration(
    gradient: LinearGradient(
      colors: [Colors.blue, Colors.purple],
      begin: Alignment.topLeft,
      end: Alignment.bottomRight,
    ),
  ),
)

âœ¨  Making Container Clickable
GestureDetector(
  onTap: () {
    print("Container Clicked!");
  },
  child: Container(
    width: 200,
    height: 100,
    color: Colors.orange,
    child: Center(child: Text("Click Me")),
  ),
)

âœ¨ Controlling Position (Using Transform):
Transform.translate(
  offset: Offset(50, 20), // Moves container
  child: Container(width: 100, height: 50, color: Colors.red),
)

âœ¨  Rounded Image Inside a Container:
Container(
  width: 100,
  height: 100,
  decoration: BoxDecoration(
    shape: BoxShape.circle,
    image: DecorationImage(image: AssetImage('assets/profile.jpg'), fit: BoxFit.cover),
  ),
)

âœ¨Summary
Feature	                Property/Method	                            Example
Set Size	              width, height	                              width: 200, height: 100
Background              Color	color	                                color: Colors.blue
Padding & Margin	      padding, margin	                            padding: EdgeInsets.all(10)
Border & Shadow	        BoxDecoration	                              BoxDecoration(border: ...)
Gradient Effect	        gradient	                                  LinearGradient(colors: [...])
Make Clickable          GestureDetector	                            onTap: () {}
Positioning	            Transform.translate	                        offset: Offset(50,20)




ğŸ¯ ğŸ› ï¸ Actions (Properties) of Button:
Flutter provides several types of buttons, such as ElevatedButton, TextButton, OutlinedButton, and more. Each has properties to control appearance, behavior, and interactions.

âœ¨ Common Properties of Buttons:
Property	                       Description	                                                         Example Usage
onPressed	                       Defines what happens when the button is clicked.	                     onPressed: () { print("Clicked!"); }
onLongPress	                     Defines action for a long press.	                                     onLongPress: () { print("Long Pressed!"); }
child	                           Defines the content inside the button.	                               child: Text("Click Me")
style	                           Customizes button design (color, shape, elevation, etc.).	           style: ButtonStyle(...)
icon	                           Used in IconButton for showing an icon.	                             icon: Icon(Icons.add)

âœ¨ Types of Buttons in Flutter
Flutter offers different buttons based on design needs:

1ï¸âƒ£ ElevatedButton (Raised Button)
Used for high-emphasis actions.

Has a shadow/elevation effect.
Code:
ElevatedButton(
  onPressed: () { print("Elevated Button Clicked!"); },
  style: ElevatedButton.styleFrom(
    backgroundColor: Colors.blue,
    padding: EdgeInsets.symmetric(horizontal: 20, vertical: 10),
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
  ),
  child: Text("Click Me", style: TextStyle(color: Colors.white)),
)


2ï¸âƒ£ TextButton (Flat Button)
Used for low-emphasis actions.

No elevation, just plain text.
Code:
TextButton(
  onPressed: () { print("Text Button Clicked!"); },
  child: Text("Click Me", style: TextStyle(color: Colors.blue)),
)


3ï¸âƒ£ OutlinedButton
Similar to TextButton but has a border.
Code:
OutlinedButton(
  onPressed: () { print("Outlined Button Clicked!"); },
  style: OutlinedButton.styleFrom(
    side: BorderSide(color: Colors.blue, width: 2),
  ),
  child: Text("Click Me"),
)


4ï¸âƒ£ IconButton
Used for buttons with only an icon (like "back" or "add" icons).
Code:
IconButton(
  onPressed: () { print("Icon Button Clicked!"); },
  icon: Icon(Icons.thumb_up, color: Colors.blue, size: 30),
)


âœ¨ Customizing Button Styles
 Example: Fully Styled Button:

ElevatedButton(
  onPressed: () { print("Styled Button Clicked!"); },
  style: ElevatedButton.styleFrom(
    backgroundColor: Colors.green, 
    foregroundColor: Colors.white, 
    elevation: 5, 
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(30),
    ),
  ),
  child: Text("Styled Button"),
)


âœ¨ Disable a Button
A button can be disabled by setting onPressed: null.
Code:
ElevatedButton(
  onPressed: null, // Button is disabled
  child: Text("Disabled Button"),
)


âœ¨ Button with an Icon
Combine an icon and text inside a button.
Code:
ElevatedButton.icon(
  onPressed: () { print("Button with Icon Clicked!"); },
  icon: Icon(Icons.send, color: Colors.white),
  label: Text("Send"),
  style: ElevatedButton.styleFrom(backgroundColor: Colors.blue),
)

âœ¨ Summary Table
Feature	                 Property/Method	                           Example
Click Action	           onPressed	                                 onPressed: () {}
Long Press	             onLongPress	                               onLongPress: () {}
Text Inside	             child	                                     child: Text("Click Me")
Button Color	           style: ButtonStyle	                         backgroundColor: Colors.blue
Border Shape	           shape	                                     RoundedRectangleBorder(...)
Disable Button	         onPressed: null	                           onPressed: null
Add Icon	               icon, label	                               ElevatedButton.icon(...)




ğŸ¯ ğŸ› ï¸ Actions (Properties) of AppBar:
The AppBar is a material design widget that appears at the top of the screen and provides navigation, branding, and actions for an app. It is typically used inside a Scaffold.

âœ¨ Common Properties of AppBar
Property	                            Description	                                                                           Example Usage
title	                                Displays the title text in the center/left.	                                           title: Text("My App")
leading	                              Widget placed at the start (left) of the AppBar (e.g., Back button, Drawer icon).	     leading: Icon(Icons.menu)
actions	                              List of widgets placed at the end (right) of the AppBar (e.g., search, settings).	     actions: [Icon(Icons.search)]
backgroundColor	                      Sets the background color of the AppBar.	                                             backgroundColor: Colors.blue
elevation	                            Adds shadow depth effect to AppBar.	                                                   elevation: 4.0
centerTitle	                          Centers the title text (true or false).	                                               centerTitle: true
flexibleSpace	                        Adds a custom flexible background (e.g., gradient, image).	                           flexibleSpace: Container(...)
shadowColor	                          Color of the shadow (used with elevation).	                                           shadowColor: Colors.grey
toolbarHeight	                        Custom height of the AppBar.	                                                         toolbarHeight: 80.0
shape	                                Customizes the AppBar border shape.	                                                   shape: RoundedRectangleBorder(...)
bottom	                              Adds a bottom widget (e.g., TabBar).	                                                 bottom: PreferredSize(...)

âœ¨ AppBar with a Leading Icon
AppBar(
  title: Text("Home"),
  leading: IconButton(
    icon: Icon(Icons.menu),
    onPressed: () { print("Menu Clicked"); },
  ),
)


âœ¨ AppBar with Actions (Search & Settings)
AppBar(
  title: Text("Dashboard"),
  actions: [
    IconButton(
      icon: Icon(Icons.search),
      onPressed: () { print("Search Clicked"); },
    ),
    IconButton(
      icon: Icon(Icons.settings),
      onPressed: () { print("Settings Clicked"); },
    ),
  ],
)


âœ¨ AppBar with Bottom TabBar
AppBar(
  title: Text("Tabbed AppBar"),
  bottom: TabBar(
    tabs: [
      Tab(icon: Icon(Icons.home), text: "Home"),
      Tab(icon: Icon(Icons.person), text: "Profile"),
    ],
  ),
)


âœ¨ Summary Table
Feature	                       Property/Method	                              Example
Title	                         title	                                        title: Text("My App")
Leading Icon	                 leading	                                      leading: Icon(Icons.menu)
Actions	                       actions	                                      actions: [Icon(Icons.search)]
Background	                   backgroundColor	                              backgroundColor: Colors.blue
Elevation	                     elevation	                                    elevation: 4.0
Shadow Color	                 shadowColor	                                  shadowColor: Colors.grey
Center Title	                 centerTitle	                                  centerTitle: true
Custom Shape	                 shape	                                        shape: RoundedRectangleBorder(...)
Bottom Widget	                 bottom	                                        bottom: TabBar(...)




ğŸ¯ ğŸ› ï¸ Actions (Properties) of Row,Column and Expanded:
These are fundamental layout widgets in Flutter used to arrange child widgets horizontally (Row), vertically (Column), and distribute space efficiently (Expanded).

âœ¨ Properties of Row:
Property	             Description	                                                  Example Usage
children	             A list of widgets inside the Row.	                            children: [Text("A"), Icon(Icons.star)]
mainAxisAlignment	     Aligns children horizontally along the main axis.	            mainAxisAlignment: MainAxisAlignment.center
crossAxisAlignment	   Aligns children vertically (opposite to main axis).	          crossAxisAlignment: CrossAxisAlignment.start
mainAxisSize	         Defines the space the Row takes (min or max).	                mainAxisSize: MainAxisSize.max
textDirection	         Defines text layout (ltr or rtl).	                            textDirection: TextDirection.ltr

Example:
Row(
  mainAxisAlignment: MainAxisAlignment.spaceAround,
  crossAxisAlignment: CrossAxisAlignment.center,
  children: [
    Icon(Icons.star, size: 30),
    Text("Hello", style: TextStyle(fontSize: 20)),
    Icon(Icons.favorite, size: 30),
  ],
)


âœ¨ Properties of Column:
Property	               Description                                        	           Example Usage
children	               A list of widgets inside the Column.	                           children: [Text("Item 1"), Text("Item 2")]
mainAxisAlignment      	 Aligns children vertically.	                                   mainAxisAlignment: MainAxisAlignment.center
crossAxisAlignment	     Aligns children horizontally.	                                 crossAxisAlignment: CrossAxisAlignment.start
mainAxisSize	           Defines space the Column takes (min or max).	                   mainAxisSize: MainAxisSize.min
textBaseline	           Aligns text based on baseline (alphabetic, ideographic).	       textBaseline: TextBaseline.alphabetic

Example:
Column(
  mainAxisAlignment: MainAxisAlignment.center,
  crossAxisAlignment: CrossAxisAlignment.start,
  children: [
    Text("Welcome", style: TextStyle(fontSize: 22)),
    Icon(Icons.home, size: 30),
    Text("Flutter Column Example"),
  ],
)

âœ¨ Properties of Expanded
Property	                 Description	                                             Example Usage
child	                     The widget inside Expanded.	                             child: Container(color: Colors.red)
flex	                     Defines space ratio among multiple Expanded widgets.	     flex: 2

Example:
Row(
  children: [
    Expanded(
      flex: 2,
      child: Container(color: Colors.blue, height: 50),
    ),
    Expanded(
      flex: 1,
      child: Container(color: Colors.red, height: 50),
    ),
  ],
)





ğŸ¯ ğŸ› ï¸ Actions (Properties) of ListView
These properties modify the behavior and appearance of a ListView:

âœ¨Property	          Description:
ğŸ—ï¸itemExtent:        Sets a fixed height/width for list items, improving performance.
ğŸ—ï¸reverse	:          If true, the list starts from the bottom and scrolls up. Default is false (top to bottom).
ğŸ—ï¸scrollDirection	:  Defines scroll direction: Axis.vertical (default) or Axis.horizontal.
ğŸ—ï¸shrinkWrap	:      If true, ListView takes only required space instead of filling the screen. Useful inside another scrollable widget.
ğŸ—ï¸physics	:          Controls scrolling behavior (e.g., disable scrolling with NeverScrollableScrollPhysics()).
ğŸ—ï¸primary	:          If true, this ListView is the primary scroll view.
ğŸ—ï¸cacheExtent	:      Preloads items beyond the visible area for smoother scrolling.
ğŸ—ï¸padding	:          Adds space inside the ListView.
ğŸ—ï¸controller:        Used for programmatic scrolling and listening to scroll events.

Ex:
ğŸ¯
ListView.builder(
  itemCount: 10,
  itemExtent: 80, // Fixed height for performance
  scrollDirection: Axis.vertical, // Scrolls up/down
  reverse: false, // Normal scroll direction
  shrinkWrap: true, // Takes required space only
  physics: BouncingScrollPhysics(), // Adds bounce effect
  itemBuilder: (context, index) {
    return ListTile(title: Text('Item $index'));
  },
);





ğŸ¯ ListTile (Standard List Item)
ListView(
  children: [
    ListTile(
      leading: Icon(Icons.person),
      title: Text('John Doe'),
      subtitle: Text('Software Engineer'),
      trailing: Icon(Icons.arrow_forward_ios),
    ),
    ListTile(
      leading: Icon(Icons.person),
      title: Text('Jane Smith'),
      subtitle: Text('UI Designer'),
      trailing: Icon(Icons.arrow_forward_ios),
    ),
  ],
);



ğŸ¯ ğŸ› ï¸ Properties of ListView.builder
âœ¨Property	Description :
ğŸ—ï¸itemCount :	Defines the total number of items in the list.
ğŸ—ï¸itemBuilder	:A function that dynamically builds each item. It takes (context, index) as parameters.
ğŸ—ï¸scrollDirection	:Defines scroll direction: Axis.vertical (default) or Axis.horizontal.
ğŸ—ï¸shrinkWrap	:If true, ListView takes only required space instead of filling the screen. Useful inside another scrollable widget.
ğŸ—ï¸physics	:Controls scrolling behavior (e.g., BouncingScrollPhysics(), NeverScrollableScrollPhysics()).
ğŸ—ï¸reverse	:If true, reverses scroll direction (list starts from bottom).
ğŸ—ï¸itemExtent	:Sets a fixed height/width for each item (better performance for uniform lists).
ğŸ—ï¸cacheExtent	:Controls how many items are preloaded beyond the visible area (default: 250.0).
ğŸ—ï¸controller	:A ScrollController for programmatic scrolling.
ğŸ—ï¸primary	:If true, this ListView is the primary scroll view in the widget tree.
ğŸ—ï¸keyboardDismissBehavior	:Defines how the list dismisses the keyboard (onDrag, manual).

Ex:
ğŸ¯ListView.builder(
  itemCount: 50, // Total number of items
  itemExtent: 80, // Fixed height for performance
  scrollDirection: Axis.vertical, // Default: Scrolls up & down
  reverse: false, // Normal scroll direction
  shrinkWrap: true, // Takes required space only
  physics: BouncingScrollPhysics(), // Adds bounce effect
  cacheExtent: 300, // Preloads additional items for smooth scrolling
  itemBuilder: (context, index) {
    return ListTile(
      title: Text('Item $index'),
      subtitle: Text('Subtitle for Item $index'),
      leading: Icon(Icons.list),
    );
  },
);




ğŸ¯ ğŸ› ï¸ Actions (Properties) of Navigation  drawer:
âœ¨  Key Properties of Drawer Widget:
Property	               Description	                                                 Example Usage
child	                   The main content of the drawer. Usually a ListView.	         child: ListView(children: [...])
backgroundColor	         Sets the drawer's background color.	                         backgroundColor: Colors.blue
elevation	               Adds a shadow effect to the drawer.	                         elevation: 16.0
width	                   Defines the width of the drawer.	                             width: 250.0


âœ¨ Key Properties of DrawerHeader (Optional):
Property	           Description	                                                  Example Usage
decoration	         Adds background color or image to the header.	                decoration: BoxDecoration(color: Colors.blue)
margin	             Sets the margin around the header.             	              margin: EdgeInsets.zero
child	               Contains widgets inside the header (Text, Image, etc.).	      child: Text("My App")


 âœ¨ Key Properties of ListTile (Menu Items in Drawer):
Property	                Description	                               Example Usage
leading	                  Adds an icon before the title.	           leading: Icon(Icons.home)
title	                    The main text of the menu item.	           title: Text("Home")
subtitle	                A smaller text under the title.	           subtitle: Text("Go to home")
trailing	                Adds an icon at the end (e.g., arrow).	   trailing: Icon(Icons.arrow_forward)
onTap	                    Defines the action when tapped.	           onTap: () { Navigator.pop(context); }





ğŸ¯ ğŸ› ï¸ Actions (Properties) of TextField :







ğŸ¯ ğŸ› ï¸ Actions (Properties) of TextField :
TextField Properties: 

controller	:Captures input text
decoration	:Adds labels, hints, and borders
keyboardType	:Defines the keyboard type (e.g., TextInputType.number)
obscureText	:Hides text (for passwords)
maxLength	:Limits input length
onChanged	:Runs a function when text changes
..........................................................................................

                        ğŸ—ï¸Key Differences:
Feature	                   TextField	                    TextFormField
Form Support	             âŒ No	                        âœ… Yes (works inside Form)
Validation	               âŒ No built-in    	            âœ… Yes (validator: property)
Error Handling	           âŒ Manual	                    âœ… Shows errors automatically
Use Case	                 Simple input (search, chat)	  Forms (login, registration)



ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯


When we use setState function related to TextFormField in flutter code, and there is stateLess widget in MyApp then setstate will not working and we get an   âŒerror:

âœ¨Code:
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  MyApp({Key? key}) : super(key: key);

   var _uniname;
   void _updateText(val){
  setState((){
    _uniname=val;

  }
   );
     }

   @override
....................................................................


âŒerror:  The method 'setState' isn't defined for the type 'MyApp'.

âœ¨For this ,the solution is:
We need to change MyApp to StatefulWidget so that we can update _uniname dynamically when the user enters text.

âœ¨Code:
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatefulWidget { // Change to StatefulWidget
  @override
  _MyAppState createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  var _uniname = "";       // Initialize variable

  void _updateText(val) {
    setState(() {
      _uniname = val; // Update state variable
    });
  }

  @override
.............................................


             The changes we fixed:
       Changes        &          Fixes:
âœ… Changed MyApp to a StatefulWidget (StatefulWidget)
âœ… Moved _uniname to _MyAppState so it can be updated
âœ… Used setState() in _updateText() to update UI

Why Convert to StatefulWidget?
âœ¨A StatelessWidget cannot update UI dynamically after it's built.
A StatefulWidget can update UI by calling setState().

Now, whenever the user types in the TextFormField, _uniname will be updated, and the text "The university name is: ..." will change dynamically.



ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯



Working of TextFormField with _uniname
Variable Declaration (_uniname)


âœ…var _uniname = "";
........................_uniname is a state variable that holds the text entered by the user.
........................It is initially an empty string ("").
........................Handling User Input (onChanged)


âœ…TextFormField(
   onChanged: (val) {
     _updateText(val);
   },
   decoration: InputDecoration(
     labelText: "Versity Name",
     prefixIcon: Icon(Icons.verified_user_outlined),
     border: OutlineInputBorder(),
   ),
),


........................onChanged: (val) â†’ When the user types in the text field, this callback function is triggered.
........................The entered text (val) is passed to _updateText(val), which updates _uniname.
........................Updating State (_updateText method)


âœ…void _updateText(val) {
   setState(() {
     _uniname = val; // Updates the variable with user input
   });
}


........................setState() is used to update _uniname, which triggers a UI rebuild to reflect the new value.
........................Displaying Updated Text


âœ…Text("The versity name is $_uniname"),

........................As _uniname changes, this Text widget dynamically updates to show the latest input.



âœ¨ Summary of TextFormField Functionality in This Code
-> It takes user input using onChanged.
-> The input is stored in _uniname via _updateText().
-> The UI updates dynamically as _uniname changes.
-> The Text widget below the input field displays the current value of _uniname.

âœ¨ Example Output
User types: "NITER"
Displayed text: "The versity name is NITER"



ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯



 âœ¨ Comparison: Which One Is More Preferable?

âœ¨Feature	                                         Using TextEditingController	                                            Using onChanged
âœ¨Complexity	                                     More complex (requires listener)	                                        Simpler (direct function call)
âœ¨Control over text field	                         More control (can clear text, set text, get value outside onChanged)	    Less control (only updates state on 
                                                                                                                                                       change)
âœ¨Performance	                                     Efficient for handling text externally	                                  Suitable for simple real-time updates
âœ¨Memory management	                               Requires dispose() to prevent memory leaks	                              No extra memory usage


If basic real-time updates are required (e.g., displaying text immediately after input), the second approach (onChanged) is preferable because it's simpler.
If more control is needed (e.g., setting initial values, clearing the field programmatically, or accessing text externally), the first approach (TextEditingController) is better.


âœ¨ Final Recommendation
For most simple use cases: Use onChanged (second approach).
If advanced text control is needed: Use TextEditingController (first approach).



ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯




ğŸ“Œ Understanding Your Flutter Code (TextFormField, Controller, and State Update)
Your Flutter code consists of a TextFormField that interacts with a TextEditingController (_uniController) and updates a variable _uniname. Let's break down how everything works step by step.

ğŸ”¹ Overview of Important Components
Component	Purpose
TextFormField	User input field (text box) where users type data.
_uniController	TextEditingController to track text input in TextFormField.
_uniname	A variable to store and display the input text.
_updateText()	Function to update _uniname when text changes.
setState()	Ensures the UI updates when _uniname changes.
ğŸ“– Step-by-Step Explanation of Code


1ï¸âƒ£ Creating the Controller (_uniController)

final TextEditingController _uniController = TextEditingController();
Purpose:
Controls the text inside TextFormField.
Allows getting and setting the input value dynamically.
Why is it needed?
Without a controller, we would have to rely on onChanged, which is less efficient.
With a controller, we can track and update text programmatically.


2ï¸âƒ£ Initializing the Controller in initState()

@override
void initState() { // Corrected method name
  super.initState();
  _uniController.addListener(_updateText);
}

What happens here?
The _updateText function is attached as a listener to _uniController.
Whenever the user types in TextFormField, _updateText() is called automatically.
This ensures _uniname gets updated when the text changes.


3ï¸âƒ£ Defining the _updateText Function

void _updateText() { // No parameter needed
  setState(() {
    _uniname = _uniController.text; // Get the latest text
  });
}

What does this function do?
Calls setState(), which tells Flutter to rebuild the UI with updated data.
Assigns the latest input from _uniController.text to _uniname.

Why is setState() used?
Without setState(), the UI wouldnâ€™t update when _uniname changes.


4ï¸âƒ£ TextFormField Setup

TextFormField(
  controller: _uniController,  // Connects the controller to the input field
  decoration: InputDecoration(
    labelText: "Versity Name",
    prefixIcon: Icon(Icons.verified_user_outlined),
    border: OutlineInputBorder(),
  ),
),

Key Properties:

Property	Purpose
controller: _uniController	Links the input field to _uniController.
labelText: "Versity Name"	Displays a floating label inside the input box.
prefixIcon: Icon(Icons.verified_user_outlined)	Adds a user icon before the text field.
border: OutlineInputBorder()	Adds a border around the text field.
How does it interact with _uniname?

When the user types something, _uniController automatically stores that text.
Since _uniController.addListener(_updateText); is set up, _updateText() runs when text changes, updating _uniname.


5ï¸âƒ£ Displaying the Entered Text

Text("The versity name is ${_uniController.text}"),
Why use _uniController.text instead of _uniname?
_uniname stores the latest text, but directly accessing _uniController.text ensures real-time updates.
This means when the user types, the text updates instantly without delay.
ğŸ’¡ Key Takeaways
âœ… Using a Controller (TextEditingController) is Better Than onChanged

TextEditingController allows direct access and modification of the text.
It keeps track of text input in real-time.
âœ… Listeners Automatically Update the UI

_uniController.addListener(_updateText); ensures _uniname updates when text changes.
âœ… setState() is Essential for UI Updates

Without setState(), changes to _uniname wouldnâ€™t reflect on the screen.



ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯




1ï¸âƒ£ Difference in _updateText() Function Signature

âœ¨First Code: The Correct form :âœ…

void _updateText() { // No parameter needed
  setState(() {
    _uniname = _uniController.text; // Get the latest text
  });
}

........................Does not take any parameters because it is used as a listener in addListener(_updateText).
........................TextEditingController calls _updateText() without arguments whenever text changes.


âœ¨Second Code: The incorrect form :

void _updateText(val) {
  setState(() {
    _uniname = _uniController.text; // Update state variable
  });
}

........................Takes a parameter (val), but this is incorrect for a listener.
........................addListener(_updateText) expects a function without arguments, so this will cause an error unless _updateText(val) is modified.




ğŸ›  Fix:
........................To use _updateText(val), you should modify the listener like this:

âœ¨ _uniController.addListener(() => _updateText(_uniController.text));
........................But this is unnecessary because _uniController.text is already accessible inside _updateText().




2ï¸âƒ£ Difference in TextEditingController Declaration
âœ¨First Code: 

final TextEditingController _uniController = TextEditingController();

........................Declares _uniController as a final variable at the time of class initialization.
........................This is the preferred way because it ensures TextEditingController is properly managed.


âœ¨Second Code:

final _uniController = TextEditingController();

........................Same declaration, so no issue here.




3ï¸âƒ£ initState() Placement
âœ¨First Code:

@override
void initState() {
  super.initState();
  _uniController.addListener(_updateText);
}


........................Calls super.initState() before adding the listener (âœ… Correct).


âœ¨Second Code:

void initState() { // Corrected method name
  super.initState();
  _uniController.addListener(_updateText);
}


........................Same functionality (No issue here).



4ï¸âƒ£ dispose() Method Missing in Second Code

âœ¨First Code (Better Practice)

@override
void dispose() {
  _uniController.dispose(); // Prevents memory leaks
  super.dispose();
}


........................Properly disposes of _uniController to prevent memory leaks.

âœ¨Second Code

........................âŒ Does not include dispose(), which can cause memory leaks when the widget is removed.





                                    âœ… Summary of Differences
Feature                            	First Code (âœ… Better)	                      Second Code
_updateText() Signature	            No parameter (Correct for addListener)	      Takes val (Incorrect for addListener)
TextEditingController Declaration	  âœ… Declared correctly	                        âœ… Declared correctly
initState()	                        âœ… Calls super.initState() first	            âœ… Calls super.initState() first
dispose() Method	                  âœ… Included (Prevents memory leaks)	          âŒ Missing (Can cause memory leaks)


ğŸš€ Final Verdict
First Code is better because:
_updateText() does not take parameters (âœ… Correct for addListener).
It disposes of TextEditingController properly (âœ… No memory leaks).


Second Code has issues:
_updateText(val) is incorrect for addListener.
No dispose() method, which can cause memory leaks.


Fix for Second Code: If you want to keep the second code, you should:

âœ¨Fix _updateText(val) to _updateText():

void _updateText() {
  setState(() {
    _uniname = _uniController.text;
  });
}


âœ¨Add dispose() Method:

@override
void dispose() {
  _uniController.dispose();
  super.dispose();
}


ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯



âœ¨error: Navigator operation requested with a context that does not include a Navigator.
The error occurs because Navigator.push is being called inside the myBtn function, which is outside the build method. The issue is that context used in myBtn might not be directly associated with a Navigator.

âœ¨Solution:
Wrap the myBtn function call inside a Builder widget when calling it inside ListView. This ensures that Navigator.push gets the correct BuildContext.

âœ¨Fix:
Modify this part inside body where myBtn(context) is called:

SizedBox(height: 60),
Builder(
  builder: (context) {
    return myBtn(context);
  },
),

âœ¨Explanation:
Builder provides a new BuildContext that is properly associated with a Navigator, preventing the error.
Now, Navigator.push(context, ...) will work correctly.


ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯


Differences in TextFormField Implementation:
Code 1 (Using TextEditingController)

TextFormField(
  controller: _uniController,
  onChanged: (val) {
    _updateText();
  },
  decoration: InputDecoration(
    labelText: "Versity Name",
    prefixIcon: Icon(Icons.verified_user_outlined),
    border: OutlineInputBorder(),
  ),
),
Text("The versity name is ${_uniController.text}"),
âœ… Key Features:

âœ¨Uses a TextEditingController (_uniController) to manage text input.
âœ¨The onChanged callback calls _updateText();, but it does not pass any arguments.
âœ¨_updateText() updates _uniname using _uniController.text.
âœ¨Text display is dynamically updated using _uniController.text.

Code 2 (Using onChanged Directly)

TextFormField(
  onChanged: (val) {
    _updateText(val);
  },
  decoration: InputDecoration(
    labelText: "Versity Name",
    prefixIcon: Icon(Icons.verified_user_outlined),
    border: OutlineInputBorder(),
  ),
),
Text("The versity name is $_uniname"),

âœ… Key Features:

âœ¨Does not use TextEditingController.
âœ¨onChanged passes val (user input) to _updateText(val).
âœ¨_updateText(val) directly updates _uniname.
âœ¨Text display is updated using the _uniname variable.

Comparison:
Difference	Code 1 (TextEditingController)	Code 2 (onChanged directly)
Uses TextEditingController?	                   âœ… Yes (_uniController)	                            âŒ No
How onChanged works	                           Calls _updateText() but does not pass a value	      Passes val directly to _updateText(val)
Text display method	                           Uses _uniController.text	                            Uses _uniname
State Management	                             Updates state via _uniController.text	              Directly updates _uniname via setState()
Best for large forms?	                         âœ… Yes (easier to manage multiple fields)	          âŒ No (managing many fields is harder)


Which Method is Preferable and Why?
ğŸ”¹ Code 1 (TextEditingController) is preferable if:

The form has multiple input fields, as TextEditingController makes it easier to manage inputs.
You need to retrieve and manipulate input data manually (e.g., clear the field, validate input).
The text field needs programmatic updates (e.g., resetting or setting predefined values).

ğŸ”¹ Code 2 (onChanged directly) is preferable if:

The form is simple with only one or two fields.
You need real-time updates in the UI every time the user types.


ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯


Functions, Variables, and Key Concepts Related to TextFormField:
âœ¨ 1. TextEditingController
A controller that allows reading, writing, and listening for changes in a text field.

final TextEditingController _controller = TextEditingController();
Used in TextFormField like this:

TextFormField(
  controller: _controller,
  decoration: InputDecoration(labelText: "Enter Name"),
),
Get user input:

String userInput = _controller.text;
Clear the field:

_controller.clear();




âœ¨ 2. onChanged
Triggers a callback whenever the user types.

TextFormField(
  onChanged: (value) {
    print("User typed: $value");
  },
),
Used to update state without a controller.




âœ¨ 3. setState()
Used in StatefulWidget to update UI dynamically.

void _updateText(String value) {
  setState(() {
    _uniname = value;
  });
}
Final Verdict
For large and complex forms â†’ Use TextEditingController (Code 1)
For simple text fields with real-time updates â†’ Use onChanged (Code 2)





ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯





âœ¨ First Approach: Using TextEditingController

final TextEditingController _uniController = TextEditingController();
String _uniname = "";

@override
void initState() { 
  super.initState();
  _uniController.addListener(_updateText);
}

void _updateText() { 
  setState(() {
    _uniname = _uniController.text; 
  });
}


âœ¨ How It Works:
TextEditingController is created to control the input field.
initState() is used to add a listener to _uniController, which calls _updateText whenever the text changes.
_updateText() updates _uniname with the latest text from _uniController.
The UI is rebuilt whenever _uniname changes.

âœ¨ Advantages:
Uses TextEditingController, which provides more control over the input field (e.g., setting initial values, clearing text).
Works efficiently if the text is needed in multiple places or if additional modifications are required.

âœ¨ Disadvantages:
Requires adding and removing listeners manually, which adds complexity.
Needs dispose() to clean up _uniController when the widget is destroyed to avoid memory leaks.



âœ¨ Second Approach: Using Direct onChanged Callback

var _uniname = ""; 

void _updateText(val) {
  setState(() {
    _uniname = val; 
  });
}


âœ¨ How It Works:
No TextEditingController is used.
The TextFormField directly calls _updateText(val) whenever the text changes.
The _updateText(val) function updates _uniname and triggers setState(), which rebuilds the UI.

âœ¨ Advantages:
Simpler and more lightweight because it doesnâ€™t require a TextEditingController.
No need to manually add or remove listeners.
No need to call dispose() since no extra object is created.

âœ¨ Disadvantages:
Lacks fine-grained control over the text field.
Cannot perform actions like clearing the field programmatically or retrieving text from outside the field easily.






ğŸ¯ ğŸ› ï¸ Actions (Properties) of CheckBox and CheckBoxListTile:

Difference Between Checkbox and CheckboxListTile in Flutter
Both Checkbox and CheckboxListTile are used to create checkboxes in Flutter, but they have different use cases and functionalities.

âœ¨Feature	             âœ¨ Checkbox	                                               âœ¨ CheckboxListTile
Definition	           A simple checkbox without a label.	                         A combination of a checkbox and a ListTile with an optional label, subtitle, and icon.
Standalone	           Needs to be wrapped in a Row or Column to include text.	   Includes built-in text, icons, and control affinity.
Use                    Case	When only a checkbox is required.                      When a checkbox needs to be associated with a label or additional content.
Customization	         Less customizable (only check/uncheck)	                     Highly customizable (text, subtitle, icons, etc.)
Default                Layout	Just a small interactive box.	                       Provides a better UI by integrating text and checkbox together.


âœ¨ When to Use Which?
âœ¨Use Checkbox when you only need a simple checkbox without text.
âœ¨Use CheckboxListTile when you need a labeled checkbox for better user experience.



ğŸ¯ ğŸ› ï¸ Actions (Properties) of RadioButton() /RadioListTile() /CustomRadioWidget() :
1ï¸âƒ£ Radio<T> Widget
The Radio widget is a simple radio button that allows users to select one option from a group.

ğŸ”¹ Properties of Radio<T>
   Property	                Description
ğŸ”¹value	                    The value that this radio button represents.
ğŸ”¹groupValue	              The currently selected value in the group.
ğŸ”¹onChanged	                A callback function when the user selects this radio button.
ğŸ”¹activeColor	              The color of the radio button when selected.
ğŸ”¹fillColor	                The color of the radio button when selected and unselected.
ğŸ”¹focusColor	              Color when the radio is in focus.
ğŸ”¹hoverColor	              Color when the radio is hovered over.
ğŸ”¹materialTapTargetSize   	Defines the tap target size.
ğŸ”¹splashRadius	            The radius of the splash effect when tapped.
ğŸ”¹visualDensity	            Adjusts the space taken by the radio.



2ï¸âƒ£ RadioListTile<T> Widget
The RadioListTile is a combination of a radio button and a ListTile. It includes a title, subtitle, and can be tapped anywhere to select the radio option.

ğŸ”¹ Properties of RadioListTile<T>
Property	Description
ğŸ”¹value	                    The value this radio button represents.
ğŸ”¹groupValue	              The currently selected value in the group.
ğŸ”¹onChanged	                A callback triggered when the user selects an option.
ğŸ”¹title	                    The primary text shown in the tile.
ğŸ”¹subtitle	                Secondary text below the title.
ğŸ”¹activeColor	              The color of the radio button when selected.
ğŸ”¹fillColor	                The color of the radio button in selected and unselected states.
ğŸ”¹dense	                    Reduces the height of the tile.
ğŸ”¹tileColor               	Background color of the tile.
ğŸ”¹selectedTileColor	        Background color when the tile is selected.
ğŸ”¹contentPadding	          Controls the padding inside the tile.
ğŸ”¹shape	                    Defines the shape of the tile (e.g., RoundedRectangleBorder).
ğŸ”¹visualDensity	            Adjusts the space taken by the tile.
ğŸ”¹controlAffinity	          Positioning of the radio button (leading, trailing).





ğŸ¯ ğŸ› ï¸ Actions (Properties) of DropDown button:
ğŸ”¹ Properties of DropdownButton
ğŸ”¹Property	             Description
ğŸ”¹items	                 A list of DropdownMenuItem widgets representing the options.
ğŸ”¹value	                 The currently selected value.
ğŸ”¹onChanged	             A callback triggered when the user selects an item.
ğŸ”¹hint	                 A widget that is displayed when no value is selected.
ğŸ”¹disabledHint	         A widget displayed when onChanged is null (Dropdown is disabled).
ğŸ”¹style	                 Defines the text style of the dropdown items.
ğŸ”¹icon	                 A custom widget to replace the default dropdown arrow.
ğŸ”¹iconSize	             The size of the dropdown arrow.
ğŸ”¹isExpanded	           If true, the dropdown takes the full width of its parent.
ğŸ”¹underline	             Defines the decoration (like an underline) for the dropdown.
ğŸ”¹dropdownColor	         The background color of the dropdown menu.
ğŸ”¹borderRadius	         Controls the roundness of the dropdown menu.



